//类似原题：*P1896 [SCOI2005] 互不侵犯*  这是进阶版
#include<iostream>
#include<string>
using namespace std;
#define mod 1000000007;
/*dp[i][j][j0][k]:
i表示现在算到第i列(*取列*是因为行太大了，状态不好表示)
j表示:当前列的状态
j0表示：前一列的状态
k表示目前一共用了几个马
存储的值表示：当前列在前一列为某一状态时的方案数 */
//相比之前的括号序列多了“状态”这一中间维度，因为这里需要判断状态,但算法思路本质相通
//但怎么解决判断条件有两列的问题？用‘笛卡尔积’，无脑但只能这样来涵盖两列的合情况
long long dp[105][1 << 6][1 << 6][21];
/*优化(*大大提高效率*):
判断时可以根据有1位采取‘移位+&’方式去对应其导致的不能摆放的位置
另外由于对称性，此列和上一列的摆放判断时互相的，不用额外判断此列对上一列的影响
*/
int cnt[1 << 6];//用于提前记录枚举的某个情况的马放置个数，便于后面的统计计算

int main(){
    int N, M, K;
    cin >> N >> M >> K;

    for (int i = 0; i < (1 << 6);i++){
        int x = i;
        while(x>0){
            cnt[i] += x & 1;
            x = x >> 1;
        }
    }
    //开始dp
    dp[0][0][0][0] = 1;
    for (int i = 1; i <= M;i++){//当前计算的列
        //枚举本列可能情况
        for (int j = 0; j < (1 << N);j++){
            //枚举前一列的状态
            for (int j0 = 0; j0 < (1 << N); j0++){
                if((j&(j0<<2))|(j&(j0>>2)))
                    continue;//若不为0,就说明此情况下有棋子放在了不能放的位置
                //枚举当前马总数；k从cnt[j]+cnt[j0]开始是因为这俩状态都已枚举，是确定的，k不可能比俩和还小
                for (int k = cnt[j]+cnt[j0]; k <= K;k++){
                    //枚举前前列的状态
                    for (int j1 = 0; j1 < (1 << N);j1++){
                        if((j&(j1<<1))|(j&(j1>>1)))
                            continue;//不为0,就说明前前列也不行
                        //若可以,把前一列的‘j0,j1’状态下的方案加上去(tips：前一列的k'=k-cnt[j])
                        /*和《哈密顿回路》类似，枚举状态的dp，是根据状态间的关系去推的
                        但和《括号序列》不同，括号序列的方案是和括号添加的位置有关的，而非某次添加后的状态
                        这里枚举的是状态，而非可选位置，因此dp间的关系是‘加’而不是‘求和’
                        */
                        
                        dp[i][j][j0][k] = (dp[i][j][j0][k] + dp[i - 1][j0][j1][k-cnt[j]]) % mod;
                    }
                }
            }
        }
    }
    long long sum = 0;
    for (int i = 0; i < (1 << N);i++){
        for (int j = 0; j < (1 << N);j++){
                sum = (sum + dp[M][i][j][K]) % mod;
        }
    }
    cout << sum;
    return 0;
}