#include<iostream>
//从2021个点，2020条边可见，显然可以看作"树"结构
//因此题目的本质就是求“*最小生成树*”，模板题
/*错误思路*：每一次只按‘某待加入的点’与当前树的‘所有连边的最小边’加
为什么错？
因为这样只是对于该点是最小的,不能保证最终所有抉择(包括后面)里面是最小的,万一后面遇到更小的边就爆了！
*因此不能盲目加入点，应该按边加入点*
解决方法1(普里姆算法):每次选择的是最小的边对应的节点加入;
        *且实时更新剩余点到树的最小权重*，这样保证始终是最小边选择
解决方法2(克鲁斯卡尔算法):集合思想,但每次遍历也都是在集合与集合间取最小的边连接

总结：*本质*(贪心思想)都是尽可能取到的是最小的边
tips:从哪个结点开始都可以,因为再怎么选最小边,都最终要连接所有点,所以对于一个点,不可能不选到它的最短边
*/
int all[2025][2025]={0};
int min[2025];//存第i个点到树的最小边是多少
int tree[2025] = {0};//标记已入树的点
int main(){
    //生成边
    for (int i = 1; i < 2022;i++){
        for (int j = i + 1; j < 2022;j++){
            int a = i, b = j;
            while(a>0||b>0){
                if(a%10!=b%10){
                    all[i][j] += a % 10 + b % 10;
                }
                a /= 10, b /= 10;
            }
            all[j][i] = all[i][j];
        }
    }
    //生成树
    //初始化min数组,memset不能用,它是初始化字符型的,可以赋0但不能赋1e9
    for (int i = 0; i < 2025;i++){
        min[i] = 1e9;
    }
    int sum = 0;
    min[1] = 0;//假设从1开始,相当于1到1的距离为0
    for (int i = 0; i < 2020;i++){//2020条边
        int min_s = 1e9,index=0;
        for (int j = 1; j < 2022;j++){
            if(!tree[j]&&min_s>min[j]){
                min_s = min[j];
                index = j;
            }
        }
        tree[index] = 1;
        sum += min_s;
        //*优化*:怎么高效更新min？
        //其实每次只有新加入的结点会对记录有影响,因此把新结点和记录比一下即可
        for (int j = 1; j < 2022;j++){
            if(!tree[j]){
                min[j] = min[j] < all[j][index] ? min[j] : all[j][index];
            }
        }
    }

    std::cout << sum;
    return 0;
}