//原题参考：CF965D
#include<iostream>
using namespace std;
/*题解，设:跳跃能力为y,河宽为n
首先一点：来回有没有区别？没有！
    因为对于一条合法路线，不分左右
    因此，来回x次相当于从一岸到另一岸2x次
    而一只青蛙跳2x次=2x只青蛙一次性跳到对岸，这是等价的
接下去思考过程：
    开始时，[1,y]内所有石头高度和必须>=2x，否则第一步这些青蛙就过不去
    接下去从末尾青蛙的位置上开始考虑(毕竟它们过得去才是真正的可行)
    设其位置为i,个数为k
    对于它们前面[i+1,i+y]的区间,已经有2x-k只蛙要么在里面,要么经过了
    因此区间剩下必须还有>=k的高度和存在,再算上前面2x-k只蛙的消耗
    从此得出该区间初始高度和必须>=2x
    当末尾蛙跳过去后,再考虑新情况下的末尾蛙...直到[n-y,n-1]若也满足,必可行,接下去直接跳到对岸即可
于是递推得证：
    中间经过的任何区间的石头高度和都要>=2x才可行
(虽然以单只蛙跳2x次也能类似考虑,即任何y长度区间都必定会经过2x次,但没上述思路明了可观)*/
int n, x;
long long H[10005];
bool check(int);

//*关键*任何y区间内石头高度和都要>=2x
int main(){
    cin >> n >> x;
    for (int i = 1; i < n;i++){
        cin >> H[i];
        H[i] += H[i - 1];
    }
    //接下去的主要问题是：怎么选择一个y,选择后又要怎么判断其是否全区间符合？
    //考虑到n数据规模，一次一格增大y去check效率太低
    //而恰好每个y对应的第一个区间[1,y]是严格与y成正比例的
    //所以可以按第一个区间二分法取y(或者说:显然y越大越好,从y数值角度理解二分法)
    int l = 1, r = n - 1, mid;
    //a[r]<A<=a[l]
    while(l<=r){
        mid = (r + l) / 2;
        if(check(mid)){
            r = mid - 1;
        }else{
            l = mid + 1;
        }
    }
    cout << l;
    return 0;
}

bool check(int y){
    for (int i = 1; i < n - y;i++){
        if(H[i+y]-H[i]<2*x){
            return 0;
        }
    }
    return 1;
}