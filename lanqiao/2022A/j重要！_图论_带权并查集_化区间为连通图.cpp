#include<iostream>
using namespace std;
/*
第一下感觉是：
    相当于对长度N的棒子切分，可以用链表，不断切分或合并操作：
    但细想发现对于同起点(或同终点的)才能切分，且合并会丢失小段数据
    所以不能这么做
换个思路：
    对于要求的S'，若可知则S'必然可以写作若干小段和
    说明要尽可能得到各小段的和，而小段要么是直接给出的，要么就是作差能得到的
    所以考虑作差能得到小段的情况：
        只有两种：开头同起点，或结尾同终点
    但是切分太多小段会严重影响效率，显然不能这么处理，怎么办？
更进一步：
    为什么要求小段？上面求小段的本质目的是：
        为了在求待求段时*弥补无法单纯用已知段相加表示出某些长度的缺陷*
        因为已知段都是默认从小到大、和为正的一整段
    那么不妨思考：怎么找到‘切分小段’的等价表示方法？
        *小段=段1-段2=段1+(-段2)*，负即代表从大到小
        *那么其实相当于在原已知段中加入一个从大到小的、和为负的段2*
        (这就像之前那道砝码称重题，等价加入负重量砝码)
    这样就可以只凭已知段相加表示出某些长度
升华(识别出本质数学模型)：
    既然出现了负的段，就不能按之前的思路去从小到大累加求和了
    因为可能存在反复折回最终求得结果的可能
    这时注意到：
        这种操作就像走路，如同*图上俩结点的连通*，即从l到r的弯弯绕绕的路径
        于是就可以转化为了*连通图求路径权值*
    从图论角度：
        *区间[l,r]就是l-1~r节点*(或l到r+1，反正只要点序号和边序号对应就行)的路径
        区间和就是路径总权值！
最终问题：
    怎么判断路径有无？
        运用*并查集*
        但这里不能直接左右互指，否则会有循环
        *所以只能构建一条方向边*
    若用并查集，在*合并时怎么处理边权*？
        因为并查集存储的是祖先结点，但祖先结点到别的点的权未知
        不妨先分类讨论以下情况：
            1.当某一个是祖先结点时，直接让它指向另一个结点即可，此时边权已知
            2.若两个都不是，注意到：
                某个结点到祖先结点的权 = -祖先结点到它的权
                于是祖先结点到另一个结点的边权就能推出
            至于选哪边的祖先无所谓
        (以上操作的前提是并查集是要优化操作)
        这样就解决了合并集合时的边权的问题
    *只保留一条边那还怎么求路径总权值*？
        注意到此连通图本质是从数列的区间转化来的
        因而与普通连通图最大的不同在于：
            其区间和是确定的单个值，无关路径的选择，不存在最优最劣之分
            因此哪怕只存一条边，也能算出
        由此，结合*并查集*特点：有一个结点会成为祖先结点
        不妨在存储祖先结点的同时，也记录到该祖先结点的权值
        这样最后只需要把到祖先结点的权值相加减即可快速得到俩子结点间的权值和
        存的是到祖先为正，所以祖先到结点取负即可
至此，本题解毕。
*/

const int n = 1e5 + 5;
long long z_S[n];//每个结点到祖先的权；对于祖先结点，自己到自己就是0
int zuxian[n];
int find(int);//其实可以不设置返回值，函数内赋完值，最后直接访问记录即可

int main(){
    int N, M, Q;
    cin >> N >> M >> Q;
    //先并查集初始化
    for (int i = 0; i <= N;i++){
        zuxian[i] = i;
    }
    for (int i = 1; i <= M;i++){
        long long s;
        int l, r;
        cin >> l >> r >> s;
        //原题里l与r相当于是图里的段序号
        //所以这里为了转成结点序号要l--，即让段序号和结点序号对应
        l--;
        int lz = find(l), rz = find(r);
        if(lz!=rz){
            z_S[lz] = -z_S[l] + s + z_S[r];
            zuxian[lz] = rz;
        }
    }
    //开始回答
    for (int i = 0; i < Q;i++){
        int l, r;
        cin >> l >> r;
        l--;
        int lz = find(l), rz = find(r);
        if(lz==rz){
            cout << z_S[l] - z_S[r] << endl;
        }else{
            cout << "UNKNOWN" << endl;
        }
    }
    return 0;
}

int find(int x){
    if(zuxian[x]!=x){
        int zx=find(zuxian[x]);
        z_S[x] = z_S[x] + z_S[zuxian[x]];//结点到祖先+祖先到祖先的祖先=结点到祖先的祖先
        zuxian[x] = zx;//要先加再更新，否则就把该结点的原祖先覆盖了
    }
    return zuxian[x];
}
/*
viod find(int x){
    if(zuxian[zuxian[x]]!=x){
        find(zuxian[x]);
        z_S[x]=z_S[x]+z_S[zuxian[x]];
        zuxian[x]=zuxian[zuxian[x]];
    }
}
*/