#include<iostream>
using namespace std;
//排列组合，考虑dp？
//但直接dp不好，因为这里值大小与排列无关，不好遍历！
/*思考要点：
    1、怎么标准化变化方式？（为了便于遍历）
    2、怎么标准化变化状态？（为了便于判定）
首先，排列、方案类，一般只能靠dp、图搜索解决
每一次都搜索太费时，且由于存在09跳跃，不好判定
注意到，初末变化本质就是：正负转圈数
不妨换成*残差方式*，此时发现：
    若以残差方式记录数据，所有的情况都是可以归类成统一样式的
    因为此时起点都是0000，是相同的
    这样成功化‘特殊’为‘普遍’
*不妨构建BFS（4维）!*
    其实也属于dp，只不过这里是*图搜索*（相当于队列顺序代表了dp遍历顺序！）
    (注意边界可跨越)
    直接先预处理出到各情况都最少步数，后面直接查询即可
    且这样子复杂度极大得减小了
*/
int bfs[10000],reach[10000],
    change[]={
    1000,100,10,1,
    1100,110,11,
    1110,111,
    1111
};//共十种可能方向（*注意*不要用前缀0，否则识别成八进制了！）

/*总结：
(双向广搜递归版？)至少答案正确，但初始化时间较长。。。应该是递归调用太深导致的速度慢
    其实这也不能叫广搜！递归是优先深度的，当一条路深入走完才会退出递归！
    无法做到队列那样，每一次都是只从上一层推下一层，一层推完才到下一层！
    {
        dfs类似单核运算：
            便于记录单个路径（特解），但对于总体的遍历效率低；
        bfs类似并行运算：
            便于遍历所有的路径（通解），但若只针对个别特解，有点‘杀鸡焉用牛刀’；
        像之前的两种走迷宫：
            一种是要求输出路径序列（dfs）；
            一种是输出到达的路径数（bfs）；
    }
    （虽然由于如今数据规模不断趋于大，bfs越来越有利）
这里只是对dfs进行了剪枝罢了！还是浪费了很多步骤！
换队列广搜会快非常多！！！一般深搜才用递归。。。
*/
void map(int);
int main(){
    map(0);
    int Q, a, b;
    cin >> Q;
    for (int i = 0; i < Q;i++){
        cin >> a >> b;
        int ans = 0;
        for (int j = 0; j < 4;j++){
            ans = (b % 10 - a % 10 + 10) % 10*1000 + ans/10;
            a /= 10, b /= 10;
        }
        cout << ans << ' ' << bfs[ans] << endl;
    }
    return 0;
}

void map(int x){
    reach[x]  = 1;
    for (int i = 0; i < 10;i++){
        int now = 0, ago = x, bu = change[i];
        for (int j = 0; j < 4;j++){
            now = (ago % 10 + bu % 10) % 10*1000 + now/10;
            ago /= 10, bu /= 10;
        }
        if(!reach[now]){
            bfs[now] = bfs[x] + 1;
            map(now);
        }else{
            if(bfs[x]+1<bfs[now]){
                bfs[now] = bfs[x] + 1;
                map(now);
            }
        }
    }

    for (int i = 0; i < 10;i++){
        int now = 0, ago = x, bu = change[i];
        for (int j = 0; j < 4;j++){
            now = (ago % 10 - bu % 10+10) % 10*1000 + now/10;
            ago /= 10, bu /= 10;
        }
        if(!reach[now]){
            bfs[now] = bfs[x] + 1;
            map(now);
        }else{
            if(bfs[x]+1<bfs[now]){
                bfs[now] = bfs[x] + 1;
                map(now);
            }
        }
    }
    return;
}