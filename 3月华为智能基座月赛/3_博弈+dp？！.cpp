#include<iostream>
using namespace std;
/*关键在于‘谁能获胜’与‘字符串’的内在联系是什么？
1：一开始就是回文串，则科小花获胜
2：一开始不是回文，则对于某一中间状态：
    无论删首还是尾留下的都是回文：
        对方必胜
    删一头留下的是回文；
        那么为了不输，必须删另一头(即组成回文的那部分)
    （注意：
        对于“aa...aa”这种情况，显然是包含于删一头的情况里的
        因此不可能最后出现“aa..a”但双方还在进行的情况
        ）
    但是，根据数据规模，递归判断最坏情况是10^11次超时，显然需要优化
*优化*：
    首先：
        由于双方均采取最优策略，
        那么只要不出现删两头都是回文的情况，双方肯定都要回避删一头剩下是回文的选择，
        会一直删到只剩一个，最终决出胜负
        此时，胜负取决于原字符串的个数奇偶
    于是最终问题在于：怎么把删两头都输的情况涵盖进来？
        [a] [ ][ ][ ][ ][ ][ ][a]|[b]
        [a]|[b][ ][ ][ ][ ][ ][ ] [b]
    注意到，由于对称性，一但确定两头的a、b
    整个符合的字符串就只可能是：abab...ababa这种情况
    （*类比数学函数的周期性*）
    于是对这种情况分析：
        对于临界状态：cabab...aba/abab...abc (左右情况是等价的)
            若双方都不删c，这与上述情况无异
            若有一方删c，那么肯定是在ab仍然成对的情况下删c的
            因为ab不成对时就是回文串，删c就输了
            于是对于剩下的ab...ab，对方怎么选都必输
    综上，不删c的情况可并入字符个数奇偶来看，而删c的情况
    由于必输的序列是ab...ab删掉一个后是奇数，与最终删完剩一个是奇偶相同的
    因此其与奇偶个数的输赢情况相同，也可以归并
*总结*：
    输赢除了第一次的特殊情况判断外，剩下的均按奇偶判断即可
        若一开始就是回文：TSUH
        若一开始就是必输：TSUH
        else若奇数：HUST
            若偶数：TSUH
tips：
    因为这里限定了：sum{(ri-li+1)|i<-Q}<=10^7,乘3也还比较小
    所以每一次直接暴力判断即可
*/

string S;
bool huiwen(int, int);
int main(){
    int Q;
    cin >> S >> Q;
    int l,r=0;
    for (int i = 0; i < Q;i++){
        cin >> l >> r;
        if(huiwen(l,r)||(huiwen(l,r-1)&&huiwen(l+1,r))){
            cout << "TSUH" << endl;
        }else{
            if((r-l+1)%2){
                cout << "HUST" << endl;
            }else{
                cout << "TSUH" << endl;
            }
        }
    }
    return 0;
}

bool huiwen(int l, int r){
    bool flag = 1;
    while(l<r){
        if(S[l-1]!=S[r-1]){
            flag = !flag;
            break;
        }
        l++, r--;
    }
    return flag;
}